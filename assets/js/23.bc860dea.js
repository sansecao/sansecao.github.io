(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{400:function(t,e,v){t.exports=v.p+"assets/img/mvvm.aef61c85.png"},401:function(t,e,v){t.exports=v.p+"assets/img/vue-hook.6f2c97f0.png"},507:function(t,e,v){"use strict";v.r(e);var a=v(43),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue-中好的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-中好的问题"}},[t._v("#")]),t._v(" vue 中好的问题")]),t._v(" "),a("h2",{attrs:{id:"什么是-mvvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-mvvm"}},[t._v("#")]),t._v(" 什么是 MVVM")]),t._v(" "),a("p",[t._v("MVVM 最早是由微软提出来，他借鉴了桌面应用程序的 MVC 思想，在前端页面中，把 Model 用纯 js 对象（data）表示，view 负责显示（页面），两者做到了最大限度的分离，把 Model 和 view 关联起来就是 viewmodel。")]),t._v(" "),a("p",[t._v("viewmodel 负责把 model 的数据同步到 view 显示出来，还负责把 view 的修改同步会 model，view 和 model 之间的同步工作完全是自动的，无需人为干涉")]),t._v(" "),a("p",[t._v("因此开发者只需要关注逻辑，不需要手动操作 dom，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 mvvm 来统一管理")]),t._v(" "),a("p",[a("img",{attrs:{src:v(400),alt:"图解"}})]),t._v(" "),a("h2",{attrs:{id:"mvvm-与-mvc-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvvm-与-mvc-的区别"}},[t._v("#")]),t._v(" MVVM 与 MVC 的区别")]),t._v(" "),a("p",[t._v("MVC----有一个 Controller（C），使用 Model 通过控制 Controller 去控制 view 的更新，只是做到了 Model 层级的变化去实时改变 view 层的变化")]),t._v(" "),a("p",[t._v("MVVM---就是 Model 层和 View 层只互通的，两者任何一个修改都会试对方发生变化，并且两者做到了最大限度的分离")]),t._v(" "),a("h2",{attrs:{id:"amd、cmd、commonjs、和-es6-的对比-模块化开发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#amd、cmd、commonjs、和-es6-的对比-模块化开发"}},[t._v("#")]),t._v(" AMD、CMD、CommonJS、和 ES6 的对比（模块化开发）")]),t._v(" "),a("ol",[a("li",[t._v("AMD --- requireJS（异步模块）")])]),t._v(" "),a("p",[t._v("define 定义，require 引入")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("CMD --- SeaJS（同步模块）")])]),t._v(" "),a("p",[t._v("define 定义，require 引入")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("CommonJS module.exports（nodeJS）")])]),t._v(" "),a("p",[a("code",[t._v("exports.DEFAULT_COLOR = '#409eff'")]),t._v("定义，require 引入")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("ES6 特性 export/import")])]),t._v(" "),a("h2",{attrs:{id:"vue-优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-优点"}},[t._v("#")]),t._v(" vue 优点")]),t._v(" "),a("p",[t._v("mvvm 优点就是 vue 优点：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("数据和视频之间的的同步工作完全是自动的，无需人为的干涉，所以开发者只需关注业务逻辑")])]),t._v(" "),a("li",[a("p",[t._v("不需要手动操作 dom，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 mvvm 来统一管理，节省了很多精力")])])]),t._v(" "),a("h2",{attrs:{id:"vue-的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-的生命周期"}},[t._v("#")]),t._v(" vue 的生命周期")]),t._v(" "),a("p",[a("img",{attrs:{src:v(401),alt:"图解"}})]),t._v(" "),a("h2",{attrs:{id:"数据双向绑定原理-自我实现最简单的数据双绑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据双向绑定原理-自我实现最简单的数据双绑"}},[t._v("#")]),t._v(" 数据双向绑定原理（自我实现最简单的数据双绑）")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/JavaScript/对象.html#其他方法"}},[t._v("跳转")])],1),t._v(" "),a("h2",{attrs:{id:"v-if-和-v-show-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-show-的区别"}},[t._v("#")]),t._v(" v-if 和 v-show 的区别")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("v-if 是‘真正’的条件渲染，因为它会确保在切换过程中条件快中的子组件会被销毁和重建")])]),t._v(" "),a("li",[a("p",[t._v("v-show 知识单纯的控制 display，不管 true/false 都会加载和渲染")])])]),t._v(" "),a("p",[t._v("选择： 两者来比较就知道，v-if 开销比较大，v-show 只是在开始的时候有开销，如果是十分频繁的操作，建议使用 v-show，如果是加载进入总是默认值加载，建议使用 v-if")]),t._v(" "),a("h2",{attrs:{id:"组件传值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件传值"}},[t._v("#")]),t._v(" 组件传值")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("parent----\x3echild 通过 prop")])]),t._v(" "),a("li",[a("p",[t._v("child----\x3eparent 通过$emit")])]),t._v(" "),a("li",[a("p",[t._v("child----\x3echild 通过 eventBus/vuex")])])]),t._v(" "),a("h2",{attrs:{id:"计算属性-computed"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算属性-computed"}},[t._v("#")]),t._v(" 计算属性（computed）")]),t._v(" "),a("p",[t._v("计算属性的定义：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("当依赖的属性发生变化的时候，计算属性会重新计算，反之则使用缓存中的属性值")])]),t._v(" "),a("li",[a("p",[t._v("计算属性和 vue 中的 data 的数据一样，都是响应式的，只不过他必须依赖某一个或者多个数据实现，并且只有他依赖的数据值变了。他才会更新")])])]),t._v(" "),a("h2",{attrs:{id:"watch-的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch-的作用"}},[t._v("#")]),t._v(" watch 的作用")]),t._v(" "),a("p",[t._v("watch 主要作用是监听某个数据值的变化。和计算属性相比除了没有缓存，作用是一样的")]),t._v(" "),a("h2",{attrs:{id:"vue-router-相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-相关"}},[t._v("#")]),t._v(" vue-router 相关")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/posts/Vue/vue-router的两种mode.html#vue-router"}},[t._v("跳转")])],1),t._v(" "),a("h2",{attrs:{id:"keep-alive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive"}},[t._v("#")]),t._v(" keep-alive")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/posts/Vue/keep-alive.html"}},[t._v("跳转")])],1),t._v(" "),a("h2",{attrs:{id:"mixins"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mixins"}},[t._v("#")]),t._v(" mixins")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/posts/Vue/mixins.html"}},[t._v("跳转")])],1),t._v(" "),a("h2",{attrs:{id:"自定义指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令"}},[t._v("#")]),t._v(" 自定义指令")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/posts/Vue/自定义指令.html"}},[t._v("跳转")])],1),t._v(" "),a("h2",{attrs:{id:"diff-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法"}},[t._v("#")]),t._v(" diff 算法")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/posts/Vue/diff.html"}},[t._v("跳转")])],1),t._v(" "),a("h2",{attrs:{id:"vue-react-中-key-的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-react-中-key-的作用"}},[t._v("#")]),t._v(" vue/react 中 key 的作用")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("不带 key 的情况下，对于简单列表页渲染来说 diff 节点更快，这一点没有错误，但是显然这不是 key 的作用")])]),t._v(" "),a("li",[a("p",[t._v("key 的作用是什么呢？")]),t._v(" "),a("blockquote",[a("p",[t._v("首先一点要知道，key 是给每一个 vnode 的唯一 id，可以依靠 key 更准确更快地拿到 oldVnode 中对应的 vnode 节点")])])])]),t._v(" "),a("ul",[a("li",[t._v("更准确：带 key 就不可以"),a("code",[t._v("就地复用")]),t._v("，在 sameNode 函数"),a("code",[t._v("a.key === b.key")]),t._v("对比中可以避免就地复用的情况，所以更加准确")]),t._v(" "),a("li",[t._v("更快：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快（也就是说 map 是比遍历更快的）")])]),t._v(" "),a("back-to-top"),t._v(" "),a("gitask")],1)}),[],!1,null,null,null);e.default=r.exports}}]);